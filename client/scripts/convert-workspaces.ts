import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const clientRoot = path.resolve(__dirname, '..');
const sourceDir = path.join(clientRoot, 'savedWorkspaces');
const outputDir = path.join(clientRoot, 'savedWorkspacesConverted');
const generatedDir = path.join(clientRoot, 'src', 'generated');
const generatedFile = path.join(generatedDir, 'savedWorkspaces.ts');
type WorkspaceEntry = { date: string; workspace: unknown | null };

const extractJsonObject = (text: string) => {
  let depth = 0;
  let inString = false;
  let escape = false;

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    if (escape) {
      escape = false;
      continue;
    }

    if (char === '\\') {
      escape = true;
      continue;
    }

    if (char === '"') {
      inString = !inString;
      continue;
    }

    if (inString) continue;

    if (char === '{') depth += 1;
    if (char === '}') depth -= 1;
    if (depth === 0) {
      const jsonText = text.slice(0, i + 1);
      const rest = text.slice(i + 1);
      return { jsonText, rest };
    }
  }

  throw new Error('Failed to locate end of JSON object');
};

const parseSegments = (line: string, fileName: string, lineNumber: number): WorkspaceEntry[] => {
  const entries: WorkspaceEntry[] = [];
  let remaining = line.trim();
  let lastDate = '';

  while (remaining) {
    const firstBrace = remaining.indexOf('{');
    if (firstBrace === -1) {
      // No JSON found, stop processing.
      break;
    }

    const date = remaining.slice(0, firstBrace).trim() || lastDate;
    if (!date) {
      throw new Error(`Missing date before JSON object in ${fileName} at line ${lineNumber}`);
    }

    const { jsonText, rest } = extractJsonObject(remaining.slice(firstBrace));
    const workspace = jsonText === '{}' ? null : JSON.parse(jsonText);

    entries.push({ date, workspace });
    lastDate = date;
    remaining = rest.trim();
  }

  return entries;
};

async function convert() {
  const files = await fs.readdir(sourceDir);
  const jsonFiles = files.filter((file) => file.endsWith('.json'));

  await fs.mkdir(outputDir, { recursive: true });
  await fs.mkdir(generatedDir, { recursive: true });

  const workspaceMap: Record<string, WorkspaceEntry[]> = {};

  for (const file of jsonFiles) {
    const sourcePath = path.join(sourceDir, file);
    const targetPath = path.join(outputDir, file);
    const raw = await fs.readFile(sourcePath, 'utf-8');
    const lines = raw.split(/\r?\n/);

    const entries: WorkspaceEntry[] = [];
    lines.forEach((line, idx) => {
      if (!line.trim()) return;
      const parsed = parseSegments(line, file, idx + 1);
      entries.push(...parsed);
    });

    workspaceMap[file] = entries;
    const jsonOutput = JSON.stringify(entries, null, 2);
    await fs.writeFile(targetPath, jsonOutput, 'utf-8');
    console.log(`Converted ${file} -> ${targetPath} (${entries.length} entries)`);
  }

  const fileList = Object.keys(workspaceMap);
  const tsContents = [
    '// Auto-generated by scripts/convert-workspaces.ts',
    'export type SavedWorkspaceEntry = { date: string; workspace: unknown | null };',
    `export const savedWorkspaceFiles = ${JSON.stringify(fileList, null, 2)} as const;`,
    'export type SavedWorkspaceFile = typeof savedWorkspaceFiles[number];',
    "export const savedWorkspaceBasePath = '/savedWorkspacesConverted';",
    '',
  ].join('\n');

  await fs.writeFile(generatedFile, tsContents, 'utf-8');
  console.log(`Wrote generated data to ${generatedFile}`);
}

convert().catch((err) => {
  console.error(err);
  process.exit(1);
});
