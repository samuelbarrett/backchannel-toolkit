import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import crypto from 'crypto';

type SavedWorkspaceEntry = { date: string; workspace: unknown | null };

type KeptEntry = {
  entry: SavedWorkspaceEntry;
  hash: string;
  timestamp: number | null;
};

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const clientRoot = path.resolve(__dirname, '..');
const sourceDir = path.join(clientRoot, 'savedWorkspacesConverted');
const outputDir = path.join(clientRoot, 'savedWorkspacesPruned');
const generatedDir = path.join(clientRoot, 'src', 'generated');
const generatedFile = path.join(generatedDir, 'savedWorkspacesPruned.ts');

const MIN_GAP_MS = 30_000; // 30 seconds
const TARGET_MAX = 50;
const REMOVED_KEYS = new Set(['id', 'x', 'y']);

const normalizeValue = (value: unknown): unknown => {
  if (value === null || typeof value !== 'object') return value;
  if (Array.isArray(value)) return value.map(normalizeValue);

  const obj = value as Record<string, unknown>;
  const entries = Object.entries(obj)
    .filter(([key, v]) => !REMOVED_KEYS.has(key) && v !== undefined)
    .map(([key, v]) => [key, normalizeValue(v)] as const)
    .sort(([a], [b]) => a.localeCompare(b));

  const cleaned: Record<string, unknown> = {};
  for (const [key, v] of entries) cleaned[key] = v;
  return cleaned;
};

const stableStringify = (value: unknown): string => {
  if (value === null) return 'null';
  if (typeof value === 'string') return JSON.stringify(value);
  if (typeof value !== 'object') return String(value);
  if (Array.isArray(value)) return `[${value.map(stableStringify).join(',')}]`;

  const obj = value as Record<string, unknown>;
  const entries = Object.entries(obj).sort(([a], [b]) => a.localeCompare(b));
  const body = entries.map(([k, v]) => `${JSON.stringify(k)}:${stableStringify(v)}`).join(',');
  return `{${body}}`;
};

const hashWorkspace = (workspace: unknown): string => {
  const normalized = normalizeValue(workspace);
  const serialized = stableStringify(normalized);
  return crypto.createHash('sha256').update(serialized).digest('hex');
};

const parseTimestamp = (dateStr: string): number | null => {
  const ts = Date.parse(dateStr);
  return Number.isNaN(ts) ? null : ts;
};

const pruneEntries = (entries: SavedWorkspaceEntry[]): SavedWorkspaceEntry[] => {
  const valid = entries.filter((entry) => entry.workspace !== null);
  if (!valid.length) return [];

  const kept: KeptEntry[] = [];

  for (const entry of valid) {
    const hash = hashWorkspace(entry.workspace);
    const timestamp = parseTimestamp(entry.date);

    if (!kept.length) {
      kept.push({ entry, hash, timestamp });
      continue;
    }

    const last = kept[kept.length - 1];
    const hashChanged = hash !== last.hash;
    const timeOk =
      timestamp !== null &&
      last.timestamp !== null &&
      timestamp - last.timestamp >= MIN_GAP_MS;

    if (hashChanged || timeOk) {
      kept.push({ entry, hash, timestamp });
    }
  }

  const finalEntry = valid[valid.length - 1];
  const lastKept = kept[kept.length - 1];
  if (lastKept.entry !== finalEntry) {
    kept.push({
      entry: finalEntry,
      hash: hashWorkspace(finalEntry.workspace),
      timestamp: parseTimestamp(finalEntry.date),
    });
  }

  return kept.map((item) => item.entry);
};

const downsample = (entries: SavedWorkspaceEntry[], target: number): SavedWorkspaceEntry[] => {
  if (entries.length <= target) return entries;

  const step = (entries.length - 1) / (target - 1);
  const indexes = new Set<number>([0, entries.length - 1]);

  for (let i = 1; i < target - 1; i += 1) {
    const idx = Math.round(i * step);
    indexes.add(Math.min(entries.length - 1, Math.max(0, idx)));
  }

  const sorted = Array.from(indexes).sort((a, b) => a - b);
  const needed = Math.min(target, entries.length);
  if (sorted.length < needed) {
    for (let i = 0; i < entries.length && sorted.length < needed; i += 1) {
      if (!indexes.has(i)) sorted.push(i);
    }
  }

  const uniqueSorted = Array.from(new Set(sorted)).sort((a, b) => a - b);
  return uniqueSorted.map((idx) => entries[idx]);
};

const pruneFile = async (file: string) => {
  const sourcePath = path.join(sourceDir, file);
  const targetPath = path.join(outputDir, file);
  const raw = await fs.readFile(sourcePath, 'utf-8');
  const parsed: SavedWorkspaceEntry[] = JSON.parse(raw);

  const pruned = downsample(pruneEntries(parsed), TARGET_MAX);
  await fs.writeFile(targetPath, JSON.stringify(pruned, null, 2), 'utf-8');
  console.log(`Pruned ${file}: ${parsed.length} -> ${pruned.length}`);
  return { file, pruned } as const;
};

const writeGenerated = async (files: string[]) => {
  const tsContents = [
    '// Auto-generated by scripts/prune-workspaces.ts',
    'export type SavedWorkspaceEntry = { date: string; workspace: unknown | null };',
    `export const savedWorkspaceFiles = ${JSON.stringify(files, null, 2)} as const;`,
    'export type SavedWorkspaceFile = typeof savedWorkspaceFiles[number];',
    "export const savedWorkspaceBasePath = '/savedWorkspacesPruned';",
    '',
  ].join('\n');

  await fs.writeFile(generatedFile, tsContents, 'utf-8');
  console.log(`Wrote generated data to ${generatedFile}`);
};

async function main() {
  const files = (await fs.readdir(sourceDir)).filter((file) => file.endsWith('.json'));
  await fs.mkdir(outputDir, { recursive: true });
  await fs.mkdir(generatedDir, { recursive: true });

  const results = await Promise.all(files.map(pruneFile));
  const processedFiles = results.map((r) => r.file).sort();
  await writeGenerated(processedFiles);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
